// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
import type { GenericBound } from "./GenericBound";
import type { Type } from "./Type";

/**
 * The kind of a [`GenericParamDef`].
 */
export type GenericParamDefKind = { "lifetime": { 
/**
 * Lifetimes that this lifetime parameter is required to outlive.
 *
 * ```rust
 * fn f<'a, 'b, 'resource: 'a + 'b>(a: &'a str, b: &'b str, res: &'resource str) {}
 * //                      ^^^^^^^
 * ```
 */
outlives: Array<string>, } } | { "type": { 
/**
 * Bounds applied directly to the type. Note that the bounds from `where` clauses
 * that constrain this parameter won't appear here.
 *
 * ```rust
 * fn default2<T: Default>() -> [T; 2] where T: Clone { todo!() }
 * //             ^^^^^^^
 * ```
 */
bounds: Array<GenericBound>, 
/**
 * The default type for this parameter, if provided, e.g.
 *
 * ```rust
 * trait PartialEq<Rhs = Self> {}
 * //                    ^^^^
 * ```
 */
default: Type | null, 
/**
 * This is normally `false`, which means that this generic parameter is
 * declared in the Rust source text.
 *
 * If it is `true`, this generic parameter has been introduced by the
 * compiler behind the scenes.
 *
 * # Example
 *
 * Consider
 *
 * ```ignore (pseudo-rust)
 * pub fn f(_: impl Trait) {}
 * ```
 *
 * The compiler will transform this behind the scenes to
 *
 * ```ignore (pseudo-rust)
 * pub fn f<impl Trait: Trait>(_: impl Trait) {}
 * ```
 *
 * In this example, the generic parameter named `impl Trait` (and which
 * is bound by `Trait`) is synthetic, because it was not originally in
 * the Rust source text.
 */
synthetic: boolean, } } | { "const": { 
/**
 * The type of the constant as declared.
 */
type: Type, 
/**
 * The stringified expression for the default value, if provided. It's not guaranteed that
 * it'll match the actual source code for the default value.
 */
default: string | null, } };
